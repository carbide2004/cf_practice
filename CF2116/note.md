### C
1. 先想到要把所有的都变成gcd，最快的办法一定是先把一个弄成gcd，然后其它的分别和它做gcd
2. 所以DP的状态设计是f[i][j]表示将前i个中一个弄成j最少的步数
3. 状态转移：$ f[i][gcd(j,a[i])] = min(f[i][gcd(j,a[i])](其它来源的结果), f[i - 1][gcd(j,a[i])](不管a[i],前i-1个弄出gcd(j,a[i])), f[i - 1][j] + 1(前i-1个弄出j,a[i]跟它gcd一下)) $
4. 答案为$ f[n][gcd] + n - 1 $
5. 特判最开始就有gcd（可能多个）的情况

### D
1. 首先想到需要倒推
2. 构造数组c，初始c[i]=b[i]。c的含义是推到某一步时a的取值的左界，$\forall i \ a[i] >= c[i]$
3. 对于一组操作(x, y, z)
    1. 如果z!=x,y，那么这操作前的a[z]无限制，即c[z]=0(a[z]>=0)。而由于这操作前的min(a[x],a[y])等于操作后的a[z]，所以这操作前c[x]=max(c[x], c[z])，c[y]=max(c[y], c[z])，（注意这时候c[z]可能比c[x]或c[y]大，因为c[x]可能是因为后续的操作才让它变小的，至于是不是真的能让它变小，需要在倒推完之后再顺推验证，如果验证失败，自然说明了不可能，因为这已经是最能产生最终b的必要性构造了）
    2. 如果z=x或z=y，那么还是c[x]=max(c[x], c[z])，c[y]=max(c[y], c[z])，但z就有限制了，不过在c[x]或c[y]中体现了。
4. 将倒推完得到的c再顺推一遍，如果能得到b，就输出c。否则输出-1